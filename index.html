<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMORPG Game Client</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="worldMap"></div>
    <canvas id="avatarCanvas"></canvas>
    <div id="infoPanel">
        <div id="playerCount">Players: <span id="playerCountValue">0</span></div>
        <div id="playerPosition">Position: <span id="playerPositionValue">[0, 0]</span></div>
        <div id="commands">
            <div>SPACE - JUMP</div>
            <div>CTRL - DANCE</div>
        </div>
    </div>
    
    <script>
        const SOCKET_URL = 'wss://codepath-mmorg.onrender.com';
        
        class GameClient {
            constructor() {
                this.socket = null;
                this.canvas = document.getElementById('avatarCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.worldMap = document.getElementById('worldMap');
                
                // Game state
                this.playerId = null;
                this.players = {};
                this.avatars = {};
                this.myPlayer = null;
                
                // World dimensions
                this.worldWidth = 2048;
                this.worldHeight = 2048;
                
                // Viewport
                this.viewportWidth = window.innerWidth;
                this.viewportHeight = window.innerHeight;
                this.cameraX = 0;
                this.cameraY = 0;
                
                // Avatar settings
                this.avatarSize = 32;
                
                this.init();
            }

            init() {
                this.setupCanvas();
                this.connectToServer();
                this.setupEventListeners();
            }

            setupCanvas() {
                this.canvas.width = this.viewportWidth;
                this.canvas.height = this.viewportHeight;
                
                window.addEventListener('resize', () => {
                    this.viewportWidth = window.innerWidth;
                    this.viewportHeight = window.innerHeight;
                    this.canvas.width = this.viewportWidth;
                    this.canvas.height = this.viewportHeight;
                    this.updateCamera();
                    this.requestRender();
                });
            }

            connectToServer() {
                this.socket = new WebSocket(SOCKET_URL);
                
                this.socket.onopen = () => {
                    console.log('Connected to game server');
                    this.joinGame();
                };
                
                this.socket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleServerMessage(data);
                };
                
                this.socket.onclose = () => {
                    console.log('Disconnected from game server');
                };
                
                this.socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }

            joinGame() {
                const joinMessage = {
                    action: 'join_game',
                    username: 'Player'
                };
                
                console.log('Sending join game command:', joinMessage);
                this.socket.send(JSON.stringify(joinMessage));
            }

            handleServerMessage(data) {
                // Log all server messages
                console.log('Server message received:', data);
                
                switch (data.action) {
                    case 'join_game':
                        console.log('Join game response:', data);
                        if (data.success) {
                            this.playerId = data.playerId;
                            this.players = data.players;
                            this.avatars = data.avatars;
                            this.myPlayer = this.players[this.playerId];
                            
                            // Ensure player has a facing direction
                            if (this.myPlayer && !this.myPlayer.facing) {
                                this.myPlayer.facing = 'south';
                            }
                            
                            console.log('My player:', this.myPlayer);
                            console.log('All players:', this.players);
                            console.log('Available avatars:', this.avatars);
                            this.updateCamera();
                            this.requestRender();
                            console.log('Joined game successfully');
                        } else {
                            console.error('Failed to join game:', data.error);
                        }
                        break;
                        
                    case 'player_joined':
                        console.log('Player joined:', data.player);
                        this.players[data.player.id] = data.player;
                        this.avatars[data.avatar.name] = data.avatar;
                        this.requestRender();
                        break;
                        
                    case 'players_moved':
                        console.log('Players moved:', data.players);
                        Object.assign(this.players, data.players);
                        // Update my player reference if it changed
                        if (this.myPlayer && data.players[this.playerId]) {
                            this.myPlayer = data.players[this.playerId];
                            console.log('My player updated:', this.myPlayer);
                        }
                        this.updateCamera();
                        this.requestRender();
                        break;
                        
                    case 'player_left':
                        console.log('Player left:', data.playerId);
                        delete this.players[data.playerId];
                        this.requestRender();
                        break;
                        
                    default:
                        console.log('Unknown server message:', data);
                        break;
                }
            }

            updateCamera() {
                if (!this.myPlayer) {
                    console.log('No myPlayer for camera update');
                    return;
                }
                
                // Center camera on player
                this.cameraX = this.myPlayer.x - this.viewportWidth / 2;
                this.cameraY = this.myPlayer.y - this.viewportHeight / 2;
                
                // Clamp camera to world bounds
                this.cameraX = Math.max(0, Math.min(this.cameraX, this.worldWidth - this.viewportWidth));
                this.cameraY = Math.max(0, Math.min(this.cameraY, this.worldHeight - this.viewportHeight));
                
                // Update world map position with smooth movement
                this.worldMap.style.backgroundPosition = `-${Math.round(this.cameraX)}px -${Math.round(this.cameraY)}px`;
                
                // Debug logging
                console.log(`Camera update: Player at (${this.myPlayer.x}, ${this.myPlayer.y}), Camera at (${this.cameraX}, ${this.cameraY})`);
            }

            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render all players
                Object.values(this.players).forEach(player => {
                    this.renderPlayer(player);
                });
                
                // Update info panel
                this.updateInfoPanel();
            }

            updateInfoPanel() {
                const playerCountElement = document.getElementById('playerCountValue');
                const playerPositionElement = document.getElementById('playerPositionValue');
                
                if (playerCountElement) {
                    playerCountElement.textContent = Object.keys(this.players).length;
                }
                
                if (playerPositionElement && this.myPlayer) {
                    playerPositionElement.textContent = `[${Math.round(this.myPlayer.x)}, ${Math.round(this.myPlayer.y)}]`;
                }
            }

            // Optimized render that only redraws when needed
            requestRender() {
                if (this.renderRequested) return;
                this.renderRequested = true;
                requestAnimationFrame(() => {
                    this.render();
                    this.renderRequested = false;
                });
            }

            renderPlayer(player) {
                // Calculate screen position
                const screenX = player.x - this.cameraX;
                const screenY = player.y - this.cameraY;
                
                // Skip if player is outside viewport
                if (screenX < -this.avatarSize || screenX > this.viewportWidth + this.avatarSize ||
                    screenY < -this.avatarSize || screenY > this.viewportHeight + this.avatarSize) {
                    return;
                }
                
                // Get avatar data
                const avatar = this.avatars[player.avatar];
                if (!avatar) {
                    // Draw placeholder if no avatar data yet
                    this.drawPlaceholderAvatar(screenX, screenY, player.username, player.id === this.playerId);
                    return;
                }
                
                // Get current frame
                const direction = player.facing || 'south'; // Default to south if no facing
                const frameIndex = player.animationFrame || 0;
                const frameData = avatar.frames[direction];
                
                if (!frameData || !frameData[frameIndex]) {
                    // Draw placeholder if no frame data
                    this.drawPlaceholderAvatar(screenX, screenY, player.username, player.id === this.playerId);
                    return;
                }
                
                // Check if this is my player
                const isMyPlayer = player.id === this.playerId;
                
                // Check if we have a cached image
                const cacheKey = `${player.avatar}_${direction}_${frameIndex}`;
                if (this.avatarImageCache && this.avatarImageCache[cacheKey]) {
                    const cachedImg = this.avatarImageCache[cacheKey];
                    this.drawAvatarImage(cachedImg, screenX, screenY, player.username, isMyPlayer, direction);
                } else {
                    // Create image from base64 data
                    const img = new Image();
                    img.onload = () => {
                        // Cache the image
                        if (!this.avatarImageCache) this.avatarImageCache = {};
                        this.avatarImageCache[cacheKey] = img;
                        
                        this.drawAvatarImage(img, screenX, screenY, player.username, isMyPlayer, direction);
                        // Force a re-render after image loads
                        this.requestRender();
                    };
                    img.onerror = () => {
                        console.error('Failed to load avatar image');
                        this.drawPlaceholderAvatar(screenX, screenY, player.username, isMyPlayer);
                    };
                    img.src = frameData[frameIndex];
                }
            }

            drawPlaceholderAvatar(screenX, screenY, username, isMyPlayer) {
                // Draw a simple colored rectangle as placeholder
                this.ctx.fillStyle = isMyPlayer ? '#00ff00' : '#ff0000';
                this.ctx.fillRect(screenX - this.avatarSize/2, screenY - this.avatarSize/2, this.avatarSize, this.avatarSize);
                
                // Draw green circle around my player
                if (isMyPlayer) {
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY, this.avatarSize / 2 + 5, 0, 2 * Math.PI);
                    this.ctx.stroke();
                }
                
                // Draw username label
                this.drawUsernameLabel(username, screenX, screenY - this.avatarSize/2 - 5);
            }

            drawAvatarImage(img, screenX, screenY, username, isMyPlayer = false, facing = 'south') {
                // Calculate aspect ratio preserving size
                const aspectRatio = img.width / img.height;
                let width = this.avatarSize;
                let height = this.avatarSize / aspectRatio;
                
                // Center the avatar
                const x = screenX - width / 2;
                const y = screenY - height / 2;
                
                // Draw green circle around my player
                if (isMyPlayer) {
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY, this.avatarSize / 2 + 5, 0, 2 * Math.PI);
                    this.ctx.stroke();
                    
                    // Add dance effect for my player
                    if (this.isDancing) {
                        this.drawDanceEffect(screenX, screenY);
                    }
                }
                
                // Handle west direction by flipping east frames horizontally
                if (facing === 'west') {
                    this.ctx.save();
                    this.ctx.scale(-1, 1);
                    this.ctx.drawImage(img, -x - width, y, width, height);
                    this.ctx.restore();
                } else {
                    // Draw avatar normally for other directions
                    this.ctx.drawImage(img, x, y, width, height);
                }
                
                // Draw username label
                this.drawUsernameLabel(username, screenX, screenY - height / 2 - 5);
            }

            drawDanceEffect(screenX, screenY) {
                // Draw colorful particles around dancing character
                this.ctx.save();
                
                // Draw multiple colored circles around the character
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
                const particleCount = 6;
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (this.danceAnimationFrame * 0.5 + i * (Math.PI * 2 / particleCount)) % (Math.PI * 2);
                    const radius = 30 + Math.sin(this.danceAnimationFrame * 0.3) * 10;
                    const particleX = screenX + Math.cos(angle) * radius;
                    const particleY = screenY + Math.sin(angle) * radius;
                    
                    this.ctx.fillStyle = colors[i % colors.length];
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }

            drawUsernameLabel(username, x, y) {
                // Set label style
                this.ctx.fillStyle = 'white';
                this.ctx.strokeStyle = 'black';
                this.ctx.lineWidth = 2;
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                
                // Draw text with outline
                this.ctx.strokeText(username, x, y);
                this.ctx.fillText(username, x, y);
            }

            setupEventListeners() {
                // Track currently pressed keys for continuous movement
                this.pressedKeys = new Set();
                this.movementAnimationFrame = null;
                this.predictionFrameCount = 0;
                this.isJumping = false;
                this.isDancing = false;
                this.danceAnimationFrame = 0;
                this.danceInterval = null;
                
                // Add keyboard controls for movement
                document.addEventListener('keydown', (event) => {
                    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) return;
                    
                    let direction = null;
                    switch (event.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            direction = 'up';
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            direction = 'down';
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            direction = 'left';
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            direction = 'right';
                            break;
                        case ' ':
                            this.jump();
                            event.preventDefault();
                            return;
                        case 'Control':
                            this.startDancing();
                            event.preventDefault();
                            return;
                    }
                    
                    if (direction && !this.pressedKeys.has(direction)) {
                        event.preventDefault();
                        this.pressedKeys.add(direction);
                        this.sendMove(direction);
                        this.startContinuousMovement();
                    }
                });
                
                document.addEventListener('keyup', (event) => {
                    let direction = null;
                    switch (event.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            direction = 'up';
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            direction = 'down';
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            direction = 'left';
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            direction = 'right';
                            break;
                        case 'Control':
                            this.stopDancing();
                            event.preventDefault();
                            return;
                    }
                    
                    if (direction) {
                        this.pressedKeys.delete(direction);
                        if (this.pressedKeys.size === 0) {
                            this.stopContinuousMovement();
                        }
                    }
                });
                
                // Add click-to-move
                this.canvas.addEventListener('click', (event) => {
                    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
                        console.log('Socket not connected, ignoring click');
                        return;
                    }
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const clickX = event.clientX - rect.left;
                    const clickY = event.clientY - rect.top;
                    
                    // Convert screen coordinates to world coordinates
                    const worldX = clickX + this.cameraX;
                    const worldY = clickY + this.cameraY;
                    
                    console.log('Click detected:', {
                        screenX: clickX,
                        screenY: clickY,
                        cameraX: this.cameraX,
                        cameraY: this.cameraY,
                        worldX: worldX,
                        worldY: worldY
                    });
                    
                    this.sendMoveToPosition(worldX, worldY);
                });
            }

            startContinuousMovement() {
                if (this.movementAnimationFrame) return;
                
                let lastMoveTime = 0;
                const moveInterval = 100; // Send move command every 100ms for faster movement
                
                const continuousMove = (currentTime) => {
                    if (this.pressedKeys.size > 0 && this.socket && this.socket.readyState === WebSocket.OPEN) {
                        // Send move command every 100ms
                        if (currentTime - lastMoveTime >= moveInterval) {
                            const direction = Array.from(this.pressedKeys)[0];
                            this.sendMove(direction);
                            lastMoveTime = currentTime;
                        }
                        this.movementAnimationFrame = requestAnimationFrame(continuousMove);
                    } else {
                        this.movementAnimationFrame = null;
                    }
                };
                
                this.movementAnimationFrame = requestAnimationFrame(continuousMove);
            }

            stopContinuousMovement() {
                if (this.movementAnimationFrame) {
                    cancelAnimationFrame(this.movementAnimationFrame);
                    this.movementAnimationFrame = null;
                }
            }

            predictMovement(direction) {
                if (!this.myPlayer) return;
                
                // Update facing direction based on movement
                this.updateFacingDirection(direction);
                
                // Consistent movement speed
                const moveDistance = 1;
                
                let newX = this.myPlayer.x;
                let newY = this.myPlayer.y;
                
                switch (direction) {
                    case 'up':
                        newY = Math.max(0, this.myPlayer.y - moveDistance);
                        break;
                    case 'down':
                        newY = Math.min(this.worldHeight, this.myPlayer.y + moveDistance);
                        break;
                    case 'left':
                        newX = Math.max(0, this.myPlayer.x - moveDistance);
                        break;
                    case 'right':
                        newX = Math.min(this.worldWidth, this.myPlayer.x + moveDistance);
                        break;
                }
                
                // Update player position for immediate visual feedback
                this.myPlayer.x = newX;
                this.myPlayer.y = newY;
                
                // Update camera and render for smooth visual feedback
                this.updateCamera();
                this.requestRender();
            }

            updateFacingDirection(direction) {
                if (!this.myPlayer) return;
                
                // Map movement direction to facing direction
                switch (direction) {
                    case 'up':
                        this.myPlayer.facing = 'north';
                        break;
                    case 'down':
                        this.myPlayer.facing = 'south';
                        break;
                    case 'left':
                        this.myPlayer.facing = 'west';
                        break;
                    case 'right':
                        this.myPlayer.facing = 'east';
                        break;
                }
            }

            jump() {
                if (!this.myPlayer || this.isJumping) return;
                
                this.isJumping = true;
                
                // Send jump command to server
                const message = {
                    action: 'jump'
                };
                console.log('Sending jump command:', message);
                this.socket.send(JSON.stringify(message));
                
                // Visual jump effect (move up and down)
                this.performJumpAnimation();
            }

            startDancing() {
                if (!this.myPlayer || this.isDancing) return;
                
                this.isDancing = true;
                this.danceAnimationFrame = 0;
                
                // Send dance command to server
                const message = {
                    action: 'dance'
                };
                console.log('Sending dance command:', message);
                this.socket.send(JSON.stringify(message));
                
                // Start dance animation
                this.performDanceAnimation();
            }

            stopDancing() {
                if (!this.isDancing) return;
                
                this.isDancing = false;
                
                // Send stop dance command to server
                const message = {
                    action: 'stop_dance'
                };
                console.log('Sending stop dance command:', message);
                this.socket.send(JSON.stringify(message));
                
                // Stop dance animation
                if (this.danceInterval) {
                    clearInterval(this.danceInterval);
                    this.danceInterval = null;
                }
                
                // Reset to normal facing
                if (this.myPlayer) {
                    this.myPlayer.facing = 'south';
                }
                
                this.requestRender();
            }

            performDanceAnimation() {
                if (!this.myPlayer || !this.isDancing) return;
                
                // Cycle through different facing directions for dance effect
                const danceDirections = ['north', 'east', 'south', 'west'];
                
                this.danceInterval = setInterval(() => {
                    if (!this.isDancing || !this.myPlayer) {
                        clearInterval(this.danceInterval);
                        this.danceInterval = null;
                        return;
                    }
                    
                    // Cycle through dance directions
                    this.myPlayer.facing = danceDirections[this.danceAnimationFrame % danceDirections.length];
                    this.danceAnimationFrame++;
                    
                    // Update animation frame for sprite animation
                    this.myPlayer.animationFrame = (this.myPlayer.animationFrame + 1) % 3;
                    
                    this.requestRender();
                }, 200); // Change direction every 200ms
            }

            performJumpAnimation() {
                if (!this.myPlayer) return;
                
                const originalY = this.myPlayer.y;
                const jumpHeight = 20;
                const jumpDuration = 300; // 300ms
                const startTime = Date.now();
                
                const animateJump = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / jumpDuration, 1);
                    
                    // Jump curve (up then down)
                    const jumpCurve = Math.sin(progress * Math.PI);
                    this.myPlayer.y = originalY - (jumpHeight * jumpCurve);
                    
                    this.updateCamera();
                    this.requestRender();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateJump);
                    } else {
                        this.myPlayer.y = originalY;
                        this.isJumping = false;
                        this.updateCamera();
                        this.requestRender();
                    }
                };
                
                animateJump();
            }

            sendMove(direction) {
                const message = {
                    action: 'move',
                    direction: direction
                };
                console.log('Sending move command:', message);
                this.socket.send(JSON.stringify(message));
                
                // Predict movement for immediate camera update
                this.predictMovement(direction);
            }

            sendMoveToPosition(x, y) {
                const message = {
                    action: 'move',
                    x: Math.round(x),
                    y: Math.round(y)
                };
                console.log('Sending click-to-move command:', message);
                this.socket.send(JSON.stringify(message));
                
                // Show visual indicator of click target
                this.showClickTarget(x, y);
                
                // Immediately update camera for smooth movement
                this.updateCamera();
            }

            showClickTarget(worldX, worldY) {
                // Convert world coordinates to screen coordinates
                const screenX = worldX - this.cameraX;
                const screenY = worldY - this.cameraY;
                
                // Draw a temporary target indicator
                this.ctx.save();
                this.ctx.strokeStyle = '#ff0000';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(screenX, screenY, 10, 0, 2 * Math.PI);
                this.ctx.stroke();
                this.ctx.restore();
                
                // Remove the indicator after a short time
                setTimeout(() => {
                    this.requestRender();
                }, 1000);
            }
        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new GameClient();
        });
    </script>
</body>
</html>
